In this article I want to explore community, a community of software developers, testers, and users. Recently I read a couple articles on Planet KDE that discussed the KDE community, and these readings inspired me to think more about this. When thinking about software development one can think of an overarching software development or more simply a software community that consists of smaller sub-communities. You have your user community, a tester community, and your developer community. Applicable to all of these sub-communities, you have several basic categories or clouds of activities involved in the software process. You have your bug tracking activity, your source code control activity, your project management activity, a release management activity, and then a social media or community discussion/interaction community. I would like now to explore each of these sub-areas a little further with the aim of discecting these groups or categories to see how we can raise the bar for software communities even higher, and take the user, tester, and developer experience to the next level.

Since software would not even be necessary if it were not for users, we will start our discussion with the users. Let's think about how a user interacts with the software community. First, they must have a problem to solve or a task to complete. That is why software exists--to solve problems. Something as simple as checking your e-mail, could be a problem: how do I check my e-mail? The next step is to decide or figure out what software exists that solves your active problem. So how does one figure out what is available?

For the common problem cases, such as checking e-mail, sending an instant message, or surfing the web, the user likely has a set of software tools he is already familiar with. This common tool set would likely have developed over time through trial and error of various software applications. Once the user had a one or two favorites that he or she uses, knowledge of these applications would develop over time through reading about these applications and just using and figuring out things in the application, and that figuring out could include using search engines to find others who might have encountered similar issues or searching and posting questions on forums.

For other cases, a user might too start with a search engine and search for key words in the problem statement. When I say problem statement, that is just me using a term I am familiar with as a technical person. A general user likely has in his or her mind a mental description of what he or she wants to accomplish and that to him or her is their problem statement. There are specialized web sites that catalog software applications, and these include SourceForge and Freecode.com. Rather than starting with a search engine, the user might start with one of these software catalogs. Of course, a user could find related software through non-technical means, such as asking co-workers or friends. The search for available software applications addressing specific problem or task scenarios can involve a variety of methods of searching, from technical or software based to non-technical human interaction to other methods.

Once a user has identified a pool potential software available that addresses your problem statement, the user likely will then try out the available software applications. Of course, with the available resources on the Internet, it is likely the user will first use search engines to see what has already been said and discussed about the potential software solutions. Based on this research, the user likely will narrow down the pool of software to the top few potential applications that address the problem. The user then will likely try out hands-on the potential software tools and see how well they address the problem. Based on this hands-on experience, the user decides which software application to use to solve his or her problem.

It is this intermidiate phase where the interaction with other communities and other previously mentioned activities begins. Primarily the interaction experience begins as the user from his searching seeks out the home pages of the potential solution applications. How easily the user is able to navigate the home page and find the download link to the software is a key first experience. How quicly users can find information on features and how to install and use the softare is also a key early experience. Once the user downloads the software, it is critical the user has an easy time getting the software installed and how easily the user can get beyond installation problems. Once the user gets the potential solution installed, the next phase begins.

Based on the exact interaction this user had while finding a solution to his or her problem, he potentially augmented the available pool of resources that can be used by other, future users in finding potential software to solve their similar problems. This could be in the form of additional blog posts and additional comments to existing blog posts, published software reviews, new bugs reported, new forum discussions, and new published IRC chat logs. This becomes a continuous feedback loop building upon itself.

Now that the user has chosen a software application to work his or her problem, the next phase begins. As the user begins to use the software solution, he or she begins building an experience with the software. During this period of using the software, the user may find and report bugs in the software. The user may delve in and try to find workarounds to the bug. The user may also have questions about how to do a particular task in the software, and may seek out assistence whether via online forums, chats, instant messaging, mailing lists, blog comments, and other online social media. This is the main time where interaction with other sub-communities begins.

It is now that the user as he seeks help in using the software and finds and possibly reports bugs begins to interact with the software testing community and the developer community. It is in this phase that the user also begins to interact with the mentioned activities: bug tracking, source code control, project management, release management, and social media or discussion. The dance of the software community really begins in this phase, and it is this interaction that we seek to raise the bar and take to the next level of experience. This experience likely begins or continues from the home page of the chosen software solution. The home page is a prime spot to look to see where and how to report bugs, and to see where and how to ask questions and get help. The question is, do users always seek out the application's home page when looking for this information?

So to begin this experience, the user either knows of the home page for the software or he or she asks around and through discussions will get the problem solved or be directed to available resources and the user then will resolve the problem--these resources could be further human interaction through various media or could be direct resolution by the user based on reading through text-base resources. At this stage the human on the other side of the cable and the organization and quality and detail of the home page and text-based resources will impact the user's lasting impression of this chosen software. The dance starts here.

I should note too, however, that this is not all one-sided. The user him or her-self must bring to this dance a positive and patient attitude. The user must understand the nature of a diverse human and text-based resource network. Negative attitudes and "fix or help me now" thinking will absolutely do neither side of that cable any good at all.

From here we can branch our explorations into the activity zones previously mentioned. But, at this jumping off point the user essentially looks through two sets of lenses: he either submits a bug report or pokes around for help either via live interaction or by reading static resoruces--though static resources could include other people's online and even offline discussions. But from the user's perspective as he or she is not directly involved in the discussion he is just reading someone else's questions and responses. So from these to jumping off points we can further explore the zones of activity.

While I agree that a user at this point could just be curious and explore without any particular goal, for the sake of this piece I assume the user is focused towards the task at hand. :)

Let's begin the discussion with the user wanting to report a bug or potential bug he or she found while using the given software application. We therefore focus this discussion on the Bug Tracking activity cloud we mentioned before and noted on the graphic.

We can make a few assumptions about the user at this point. First, we could assume he or she has no experience writing and submitting a bug (using a bug tracking system, not just e-mailing a report to someone). We could also assume he or she has experience with only one bug tracking system. We may also assume the user has experience with some but not all bug tracking systems. Of course, an ideal case might be we assume the user has experience with all currently available bug tracking systems.

This implies and leads into the problem of tracking bugs. The nature of software development is such that anyone can write software, any kind of software. We therefore have multiple bug tracking systems available--some free, some not so free. As discussed before, there are no set, hard standards by which these systems were developed. These systems are unique in how a user interacts with it to submit a bug report. This diverse interaction means that while a user may be generally familiar with filing bug reports, even with this general experience he or she may have difficulty figuring out a particular bug tracking system.

Something to consider when thinking about writing bug reports is that of the software environment of the host computer.

So, filing a bug report is one of the early points of friction within the software community. Do software applications provide documentation that clearly shows how to file a bug for that given software application? Does this documentation explain the fields required to complete a bug report? Are there videos that walk a user through reporting a bug in essentially real time? Does the documentation clearly indicate expected field values, such as module, component, etc. that are necessary for expected bug work flow? Basically, how much effort goes into informing a user on how to correctly file a bug report, rather than making an assumption that a user already has enough information to figure it out on his or her own?

An interesting side note: Is there a checklist of things to check an application host website for great documentation on how to submit a bug?

1. Is the URL given for the bug tracker
2. What Product to choose
3. What component to choose
...
X. Are there YouTube or other videos that walk user through the process?
Etc.

A later interesting task for the user becomes how to track his or her various bug reports filed potentially for multiple products with potentially multiple bug tracking systems. This too is an area where I think we can innovate especially using social and cloud based media.

The next step is that once the user has filed a bug, he or she will want to try out the fix or continue using the software once the bug is fixed. So, how does the user become aware of the fix, and how does the user get his or her hands on the fixed application or source code with the fix applied? What sort of notification options exist in the various bug tracking systems? This leads us into another activity zone and that is source code control.

A developer fixes the bug and checks, does some unit tests, and believes the fix is working and so he or she checks in the fixed code into the application's source code control system. At this point, there is not yet a new release to download and install as we are waiting on other bug fixes and other changes to be included in the next release of the software. However, if a user desires, he or she can likely connect to the application's source code repository and download a snapshot of the code, compile it, and try out the fix. The application may or may not be usable to where the user could continue his work. Doing this is living life on the cutting edge of software development.

[Note to self, when you revise this, you can essentially "walk the diagram" and start with project management, then lead into bug tracking, then go into souce code repository, and then into release management, and then back to home"]

*** FUTURE OR LATER PART OF ARTICLE IDEAS ***

So just thought of a contributor profile page or a "Facebook for project contributors" where various relevant to the contributor stats can be show along with name and brief bio and description of interaction with the project. (Relevant stats could be bug id's fixed, feature patches contributed, etc.) - Basically give more visibility to those actual people working to make the project happen.


